<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Живое пламя — чистый HTML/CSS/JS</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111825;
      --panel-2:#0e1420;
      --text:#cbd5e1;
      --muted:#8ba3c7;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol";
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 50% 120%, #0f172a 0%, #0b1220 40%, var(--bg) 70%) no-repeat fixed,
        var(--bg);
      display:grid;
      place-items:center;
      gap:16px;
      padding:16px;
    }
    .card{
      width:min(92vw, 860px);
      background:linear-gradient(180deg,var(--panel), var(--panel-2));
      border:1px solid rgba(255,255,255,.06);
      border-radius:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
      overflow:hidden;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.06);
      background:linear-gradient(180deg, rgba(255,255,255,.05), transparent);
    }
    header .title{
      display:flex; gap:10px; align-items:center;
      font-weight:600; letter-spacing:.2px;
    }
    header .title .dot{
      width:10px; height:10px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #ffe8a7, #ff8f17 60%, #ff4d00 100%);
      box-shadow: 0 0 16px 6px rgba(255,102,0,.55), 0 0 32px 12px rgba(255,145,0,.25);
      animation: blink 2.3s ease-in-out infinite;
      filter: saturate(1.1);
    }
    @keyframes blink{
      0%,100%{ transform: scale(1); opacity: .9 }
      50%{ transform: scale(1.25); opacity: 1 }
    }
    .wrap{
      display:grid; grid-template-columns: 1fr 320px; gap:1px;
    }
    .stage{
      padding:0; background:#02060d;
      display:grid; place-items:center;
      position:relative;
      min-height: 420px;
    }
    canvas{ display:block; width:100%; height:100%; }
    .side{
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent 40%);
      padding:14px;
    }
    .controls{
      display:grid; gap:10px; align-content:start;
    }
    .row{ display:flex; align-items:center; gap:10px; }
    .row label{ font-size:12px; color:var(--muted); width:120px;}
    .row input[type=range]{ flex:1 }
    .hint{ font-size:12px; color:#9fb1d1; opacity:.9; }
    .hint code{ background:rgba(255,255,255,.06); padding:.1em .35em; border-radius:6px;}
    footer{
      padding:10px 14px; font-size:12px; color:var(--muted);
      border-top:1px solid rgba(255,255,255,.06);
      display:flex; justify-content:space-between; align-items:center;
    }
    a { color:#93c5fd; text-decoration:none }
    a:hover{ text-decoration:underline }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .row input[type=range] { display:none }
      .hint small{ display:block }
    }

    /* Stack on mobile */
    @media (max-width: 840px){
      .wrap{ grid-template-columns: 1fr }
      .side{ order:-1 }
    }
  </style>
</head>
<body>
  <div class="card">
    <header>
      <div class="title">
        <div class="dot" aria-hidden="true"></div>
        Пламя + частицы (чистый HTML/CSS/JS)
      </div>
      <div class="hint"><small>Двигай слайдеры ➜ тонкая настройка формы и искр</small></div>
    </header>
    <div class="wrap">
      <section class="stage" id="stage" aria-label="Холст анимации">
        <canvas id="flame"></canvas>
      </section>
      <aside class="side">
        <div class="controls">
          <div class="row">
            <label for="intensity">Интенсивность</label>
            <input id="intensity" type="range" min="0" max="1.6" step="0.01" value="1.0">
          </div>
          <div class="row">
            <label for="embers">Искры</label>
            <input id="embers" type="range" min="0" max="1.5" step="0.01" value="1.0">
          </div>
          <div class="row">
            <label for="turb">Турбулентность</label>
            <input id="turb" type="range" min="0" max="2" step="0.01" value="1.1">
          </div>
          <div class="row">
            <label for="size">Размер пламени</label>
            <input id="size" type="range" min="0.6" max="1.4" step="0.01" value="1.0">
          </div>
          <p class="hint">
            Чистый Canvas. Без библиотек. Частицы вылетают снизу вверх, постепенно исчезают.
            Можно просто сохранить эту страницу и открыть локально — всё работает автономно.
          </p>
          <p class="hint"><code>globalCompositeOperation: "lighter"</code> даёт мягкое свечение.</p>
        </div>
      </aside>
    </div>
    <footer>
      <span>60FPS при типовой загрузке • поддержка HiDPI</span>
      <span>© flame demo</span>
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('flame');
  const stage  = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Controls
  const ui = {
    intensity: document.getElementById('intensity'),
    embers: document.getElementById('embers'),
    turb: document.getElementById('turb'),
    size: document.getElementById('size')
  };

  // Handle DPR for crisp rendering
  let W = 800, H = 500, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1.0));

  function resize(){
    const rect = stage.getBoundingClientRect();
    W = Math.max(420, Math.floor(rect.width));
    H = Math.max(420, Math.floor(rect.height));
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  new ResizeObserver(resize).observe(stage);
  resize();

  // ---------- Utility: smooth pseudo-noise (cheap) ----------
  // Blend of sin/cos harmonics for stable, smooth turbulence-like motion
  function fnoise(x, y, t){
    // Frequencies scaled to canvas dims
    const sx = x * 0.012, sy = y * 0.015;
    const a = Math.sin(sx + t * 1.1) * 0.8 + Math.cos((sx + sy) * 0.7 - t * 0.6) * 0.6;
    const b = Math.cos(sy * 0.8 - t * 0.9) * 0.7 + Math.sin((sy - sx) * 0.5 + t * 0.8) * 0.5;
    return (a + b) * 0.5; // ~[-1,1]
  }

  // ---------- Color ramp: temperature (0..1) ----------
  function heatColor(t, alpha = 1){
    // t=0: deep red, t=1: white/yellow
    t = Math.max(0, Math.min(1, t));
    // Use piecewise to emphasize yellow core
    const r = Math.floor( clamp(0, 255, 255 * (0.6 + 0.4*t)) );
    const g = Math.floor( clamp(0, 255, 255 * (t**0.6)) );
    const b = Math.floor( clamp(0, 255, 80  * (t**2.0)) );
    return `rgba(${r},${g},${b},${alpha})`;
  }
  function clamp(a,b,v){ return Math.max(a, Math.min(b,v)); }

  // ---------- Particle systems ----------
  const flameParticles = [];
  const emberParticles = [];
  const rnd = (min, max) => min + Math.random()*(max-min);

  class FlameParticle{
    constructor(){
      this.reset();
    }
    reset(){
      // Spawn near bottom center in a horizontal band
      const flameScale = +ui.size.value; // user size factor
      const baseWidth = W * 0.22 * flameScale;
      const cx = W * 0.5 + rnd(-baseWidth, baseWidth) * 0.55;
      this.x = cx;
      this.y = H - rnd(12, 26);

      // Velocity: mostly upward
      this.vx = rnd(-0.2, 0.2);
      this.vy = -rnd(1.2, 2.1) * (0.9 + Math.random()*0.2);

      // Life & size
      this.life = rnd(0.8, 1.5); // seconds
      this.age = 0;
      this.size = rnd(6, 18) * (0.9 + Math.random()*0.3);
      this.baseSize = this.size;
      this.twinkle = Math.random()*Math.PI*2;
    }
    update(dt, t){
      const turb = +ui.turb.value;
      const n = fnoise(this.x*0.7, this.y*0.6, t*0.7) * 0.8 * turb;
      this.vx += n * 0.02;
      this.vy -= 0.01 + Math.abs(n)*0.01; // accelerate upward slightly

      // Inward pull to keep a natural tapered column
      const cx = W*0.5;
      const h = 1 - (this.y / H); // 0 at bottom, 1 at top
      const radius = (W*0.18) * (1 - h*0.85); // taper
      const dist = this.x - cx;
      const inward = -dist * 0.0025;
      this.vx += inward;

      // Integrate
      this.x += this.vx * (60*dt);
      this.y += this.vy * (60*dt);

      // Grow then shrink
      this.size = this.baseSize * (0.75 + Math.sin(this.twinkle + t*6)*0.1) * (1 - h*0.65);
      this.age += dt;

      // Recycle if out of bounds or life ended
      if(this.age > this.life || this.y < H*0.15 || Math.abs(dist) > radius*2.2){
        this.reset();
      }
    }
    draw(ctx){
      const h = 1 - (this.y / H);
      ctx.beginPath();
      const t = clamp(0,1, 0.3 + h*0.8); // temperature along height
      const alpha = clamp(0,1, 0.55 + h*0.35) * (1 - this.age/this.life);
      ctx.fillStyle = heatColor(t, alpha);
      ctx.arc(this.x, this.y, Math.max(1, this.size*0.6), 0, Math.PI*2);
      ctx.fill();
    }
  }

  class Ember{
    constructor(){
      this.reset();
    }
    reset(){
      const flameScale = +ui.size.value;
      const baseWidth = W * 0.18 * flameScale;
      this.x = W * 0.5 + rnd(-baseWidth, baseWidth);
      this.y = H - rnd(6, 22);
      this.vx = rnd(-0.25, 0.25);
      this.vy = -rnd(1.7, 2.8);
      this.life = rnd(0.8, 1.6);
      this.age = 0;
      this.size = rnd(0.8, 2.0);
      this.spin = Math.random()*Math.PI*2;
      this.blink = Math.random()*Math.PI*2;
    }
    update(dt, t){
      const n = fnoise(this.x, this.y, t*1.2);
      this.vx += n * 0.01;
      this.vy -= 0.002;
      this.x += this.vx * (60*dt);
      this.y += this.vy * (60*dt);
      this.age += dt;
      if(this.age > this.life || this.y < H*0.05){
        this.reset();
      }
    }
    draw(ctx, t){
      const k = 1 - (this.age / this.life);
      const a = clamp(0,1, 0.9 * k * (0.65 + Math.sin(this.blink + t*12)*0.35));
      ctx.beginPath();
      ctx.fillStyle = `rgba(255, ${Math.floor(200+55*k)}, ${Math.floor(80+100*k)}, ${a})`;
      const s = Math.max(0.6, this.size * (0.8 + k*0.6));
      ctx.arc(this.x, this.y, s, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Pre-populate
  function ensureCounts(){
    const intensity = +ui.intensity.value;
    const baseFlame = Math.floor(180 * intensity);
    const baseEmbers = Math.floor(70 * +ui.embers.value);

    while(flameParticles.length < baseFlame) flameParticles.push(new FlameParticle());
    while(flameParticles.length > baseFlame) flameParticles.pop();

    while(emberParticles.length < baseEmbers) emberParticles.push(new Ember());
    while(emberParticles.length > baseEmbers) emberParticles.pop();
  }
  ensureCounts();

  // Core glow — soft gradients that breathe
  function drawCore(t){
    const cx = W*0.5;
    const baseH = H*0.42 * +ui.size.value;
    const y0 = H - baseH*0.3;
    const wobble = Math.sin(t*3.1) * 6 + Math.cos(t*2.2) * 4;
    const g = ctx.createRadialGradient(cx, y0, 6 + Math.sin(t*5)*2, cx, y0, baseH*1.05 + wobble);
    g.addColorStop(0.00, 'rgba(255,245,200,0.25)');
    g.addColorStop(0.25, 'rgba(255,190,70,0.18)');
    g.addColorStop(0.55, 'rgba(255,110,20,0.08)');
    g.addColorStop(1.00, 'rgba(0,0,0,0.0)');

    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // Base coal glow
    const g2 = ctx.createRadialGradient(cx, H-6, 4, cx, H-6, 48);
    g2.addColorStop(0, 'rgba(255,160,40,0.35)');
    g2.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g2;
    ctx.fillRect(0,0,W,H);
  }

  // Main loop
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    const t = now/1000;

    ensureCounts();

    // Motion trail: paint translucent dark veil
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(2, 6, 13, 0.28)';
    ctx.fillRect(0,0,W,H);

    drawCore(t);

    // Particles
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<flameParticles.length;i++){
      const p = flameParticles[i];
      p.update(dt, t);
      p.draw(ctx);
    }
    for(let i=0;i<emberParticles.length;i++){
      const e = emberParticles[i];
      e.update(dt, t);
      e.draw(ctx, t);
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // UI listeners
  Object.values(ui).forEach(input => {
    input.addEventListener('input', ensureCounts);
  });

})();
</script>
</body>
</html>
